{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 초기 설정 및 의존성 설치",
        "description": "React, TypeScript, Vite 기반 프로젝트를 설정하고 필요한 의존성(shadcn/ui, Supabase 등)을 설치합니다.",
        "details": "1. Vite를 사용하여 React + TypeScript 프로젝트 생성:\n```bash\nnpm create vite@latest realtime-qa-app --template react-ts\ncd realtime-qa-app\nnpm install\n```\n\n2. shadcn/ui 설정:\n```bash\nnpx shadcn-ui@latest init\n# 설정 질문에 응답 (색상 테마, CSS 변수 등)\n```\n\n3. Supabase 클라이언트 설치:\n```bash\nnpm install @supabase/supabase-js\n```\n\n4. 기타 필요한 패키지 설치:\n```bash\nnpm install react-router-dom qrcode.react\n```\n\n5. 프로젝트 구조 설정:\n```\nsrc/\n  components/\n  hooks/\n  contexts/\n  pages/\n  lib/\n    supabase.ts\n  types/\n  utils/\n```\n\n6. 환경 변수 설정 (.env 파일):\n```\nVITE_SUPABASE_URL=your-supabase-url\nVITE_SUPABASE_ANON_KEY=your-supabase-anon-key\n```",
        "testStrategy": "1. 프로젝트가 정상적으로 빌드되는지 확인\n2. 개발 서버 실행 후 기본 페이지가 로드되는지 확인\n3. Supabase 연결이 정상적으로 설정되었는지 확인\n4. shadcn/ui 컴포넌트가 정상적으로 로드되는지 확인",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Supabase 데이터베이스 스키마 설계 및 구현",
        "description": "PRD에 명시된 데이터베이스 스키마(sessions, questions, likes 테이블)를 Supabase에 구현합니다.",
        "details": "1. Supabase 프로젝트 생성\n\n2. sessions 테이블 생성:\n```sql\nCREATE TABLE sessions (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  presenter_id UUID REFERENCES auth.users(id),\n  session_code TEXT UNIQUE NOT NULL,\n  title TEXT NOT NULL,\n  status TEXT NOT NULL CHECK (status IN ('active', 'closed')),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n```\n\n3. questions 테이블 생성:\n```sql\nCREATE TABLE questions (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  session_id UUID REFERENCES sessions(id) ON DELETE CASCADE,\n  participant_id UUID REFERENCES auth.users(id),\n  content TEXT NOT NULL,\n  likes_count INTEGER DEFAULT 0,\n  status TEXT NOT NULL CHECK (status IN ('normal', 'hidden', 'pinned', 'answered')) DEFAULT 'normal',\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n```\n\n4. likes 테이블 생성:\n```sql\nCREATE TABLE likes (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  question_id UUID REFERENCES questions(id) ON DELETE CASCADE,\n  participant_id UUID REFERENCES auth.users(id),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  UNIQUE(question_id, participant_id)\n);\n```\n\n5. 트리거 설정 (likes_count 자동 업데이트):\n```sql\nCREATE OR REPLACE FUNCTION update_likes_count()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF (TG_OP = 'INSERT') THEN\n    UPDATE questions SET likes_count = likes_count + 1 WHERE id = NEW.question_id;\n  ELSIF (TG_OP = 'DELETE') THEN\n    UPDATE questions SET likes_count = likes_count - 1 WHERE id = OLD.question_id;\n  END IF;\n  RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER likes_count_trigger\nAFTER INSERT OR DELETE ON likes\nFOR EACH ROW\nEXECUTE FUNCTION update_likes_count();\n```\n\n6. RLS(Row Level Security) 설정으로 데이터 접근 제어",
        "testStrategy": "1. 각 테이블이 올바른 스키마로 생성되었는지 확인\n2. 외래 키 제약 조건이 올바르게 작동하는지 테스트\n3. likes 테이블의 트리거가 questions 테이블의 likes_count를 올바르게 업데이트하는지 확인\n4. 샘플 데이터를 삽입하여 관계가 올바르게 설정되었는지 확인",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "인증 시스템 구현 (발표자/참가자)",
        "description": "Supabase Auth를 사용하여 발표자와 참가자를 위한 인증 시스템을 구현합니다.",
        "details": "1. Supabase 인증 설정:\n   - 이메일/비밀번호 인증 활성화\n   - 익명 인증 활성화 (참가자용)\n\n2. 인증 컨텍스트 생성 (src/contexts/AuthContext.tsx):\n```tsx\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport { supabase } from '../lib/supabase';\nimport { Session, User } from '@supabase/supabase-js';\n\ntype AuthContextType = {\n  session: Session | null;\n  user: User | null;\n  loading: boolean;\n  signIn: (email: string, password: string) => Promise<void>;\n  signUp: (email: string, password: string) => Promise<void>;\n  signOut: () => Promise<void>;\n  signInAnonymously: () => Promise<void>;\n};\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  const [session, setSession] = useState<Session | null>(null);\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      (_event, session) => {\n        setSession(session);\n        setUser(session?.user ?? null);\n        setLoading(false);\n      }\n    );\n\n    return () => subscription.unsubscribe();\n  }, []);\n\n  const signIn = async (email: string, password: string) => {\n    await supabase.auth.signInWithPassword({ email, password });\n  };\n\n  const signUp = async (email: string, password: string) => {\n    await supabase.auth.signUp({ email, password });\n  };\n\n  const signOut = async () => {\n    await supabase.auth.signOut();\n  };\n\n  const signInAnonymously = async () => {\n    await supabase.auth.signInAnonymously();\n  };\n\n  return (\n    <AuthContext.Provider value={{ session, user, loading, signIn, signUp, signOut, signInAnonymously }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n```\n\n3. 로그인 컴포넌트 구현 (src/components/auth/LoginForm.tsx)\n4. 회원가입 컴포넌트 구현 (src/components/auth/SignupForm.tsx)\n5. 익명 로그인 기능 구현 (참가자용)\n6. 인증 상태에 따른 라우팅 보호 구현",
        "testStrategy": "1. 발표자 계정 생성 및 로그인 테스트\n2. 참가자 익명 로그인 테스트\n3. 로그아웃 기능 테스트\n4. 인증 상태 유지 테스트 (페이지 새로고침 후)\n5. 보호된 라우트 접근 제한 테스트\n6. 오류 처리 및 사용자 피드백 테스트",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "세션 관리 기능 구현 (생성, 참가)",
        "description": "발표자가 세션을 생성하고 참가자가 세션 코드로 참가할 수 있는 기능을 구현합니다.",
        "details": "1. 세션 관리 훅 생성 (src/hooks/useSession.ts):\n```tsx\nimport { useState } from 'react';\nimport { supabase } from '../lib/supabase';\nimport { useAuth } from '../contexts/AuthContext';\n\nexport function useSession() {\n  const { user } = useAuth();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // 세션 생성 함수\n  const createSession = async (title: string) => {\n    if (!user) return null;\n    \n    setLoading(true);\n    setError(null);\n    \n    try {\n      // 랜덤 세션 코드 생성 (6자리)\n      const sessionCode = Math.random().toString(36).substring(2, 8).toUpperCase();\n      \n      const { data, error } = await supabase\n        .from('sessions')\n        .insert({\n          presenter_id: user.id,\n          session_code: sessionCode,\n          title,\n          status: 'active'\n        })\n        .select()\n        .single();\n      \n      if (error) throw error;\n      return data;\n    } catch (err: any) {\n      setError(err.message);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // 세션 참가 함수\n  const joinSession = async (sessionCode: string) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const { data, error } = await supabase\n        .from('sessions')\n        .select('*')\n        .eq('session_code', sessionCode)\n        .eq('status', 'active')\n        .single();\n      \n      if (error) throw error;\n      return data;\n    } catch (err: any) {\n      setError(err.message);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // 세션 상태 변경 함수\n  const updateSessionStatus = async (sessionId: string, status: 'active' | 'closed') => {\n    if (!user) return false;\n    \n    setLoading(true);\n    setError(null);\n    \n    try {\n      const { error } = await supabase\n        .from('sessions')\n        .update({ status, updated_at: new Date() })\n        .eq('id', sessionId)\n        .eq('presenter_id', user.id);\n      \n      if (error) throw error;\n      return true;\n    } catch (err: any) {\n      setError(err.message);\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return {\n    createSession,\n    joinSession,\n    updateSessionStatus,\n    loading,\n    error\n  };\n}\n```\n\n2. 세션 생성 페이지 구현 (src/pages/CreateSession.tsx)\n3. 세션 참가 페이지 구현 (src/pages/JoinSession.tsx)\n4. 세션 코드 표시 및 QR 코드 생성 컴포넌트 구현\n5. 세션 상태 관리 (활성/종료) 기능 구현",
        "testStrategy": "1. 세션 생성 기능 테스트 (제목 입력, 코드 생성)\n2. 세션 참가 기능 테스트 (유효한 코드, 유효하지 않은 코드)\n3. QR 코드 생성 및 스캔 테스트\n4. 세션 상태 변경 테스트 (활성 → 종료)\n5. 종료된 세션에 참가 시도 시 오류 처리 테스트\n6. 동일한 발표자가 여러 세션을 생성할 수 있는지 테스트",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "질문 작성 및 조회 기능 구현",
        "description": "참가자가 질문을 작성하고 세션의 모든 질문을 조회할 수 있는 기능을 구현합니다.",
        "details": "1. 질문 관리 훅 생성 (src/hooks/useQuestions.ts):\n```tsx\nimport { useState, useEffect } from 'react';\nimport { supabase } from '../lib/supabase';\nimport { useAuth } from '../contexts/AuthContext';\n\nexport function useQuestions(sessionId: string) {\n  const { user } = useAuth();\n  const [questions, setQuestions] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // 질문 목록 가져오기\n  useEffect(() => {\n    if (!sessionId) return;\n\n    setLoading(true);\n    \n    // 초기 질문 로드\n    const fetchQuestions = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('questions')\n          .select('*')\n          .eq('session_id', sessionId)\n          .order('likes_count', { ascending: false })\n          .order('created_at', { ascending: false });\n        \n        if (error) throw error;\n        setQuestions(data || []);\n      } catch (err: any) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchQuestions();\n\n    // 실시간 구독 설정\n    const subscription = supabase\n      .channel(`questions:session_id=eq.${sessionId}`)\n      .on('postgres_changes', { \n        event: '*', \n        schema: 'public', \n        table: 'questions',\n        filter: `session_id=eq.${sessionId}`\n      }, (payload) => {\n        if (payload.eventType === 'INSERT') {\n          setQuestions(prev => [payload.new, ...prev]);\n        } else if (payload.eventType === 'UPDATE') {\n          setQuestions(prev => \n            prev.map(q => q.id === payload.new.id ? payload.new : q)\n          );\n        } else if (payload.eventType === 'DELETE') {\n          setQuestions(prev => \n            prev.filter(q => q.id !== payload.old.id)\n          );\n        }\n      })\n      .subscribe();\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [sessionId]);\n\n  // 질문 작성 함수\n  const addQuestion = async (content: string) => {\n    if (!user || !sessionId) return null;\n    \n    try {\n      const { data, error } = await supabase\n        .from('questions')\n        .insert({\n          session_id: sessionId,\n          participant_id: user.id,\n          content,\n          status: 'normal'\n        })\n        .select()\n        .single();\n      \n      if (error) throw error;\n      return data;\n    } catch (err: any) {\n      setError(err.message);\n      return null;\n    }\n  };\n\n  return {\n    questions,\n    loading,\n    error,\n    addQuestion\n  };\n}\n```\n\n2. 질문 작성 폼 컴포넌트 구현 (src/components/questions/QuestionForm.tsx)\n3. 질문 목록 컴포넌트 구현 (src/components/questions/QuestionList.tsx)\n4. 질문 아이템 컴포넌트 구현 (src/components/questions/QuestionItem.tsx)\n5. 질문 정렬 기능 구현 (좋아요 수, 최신순)\n6. 질문 필터링 기능 구현 (상태별)",
        "testStrategy": "1. 질문 작성 기능 테스트\n2. 질문 목록 로드 테스트\n3. 실시간 업데이트 테스트 (다른 사용자가 질문 추가 시)\n4. 질문 정렬 기능 테스트\n5. 질문 필터링 기능 테스트\n6. 오류 처리 및 로딩 상태 표시 테스트",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "질문 관리 훅(useQuestions) 구현",
            "description": "질문 데이터를 관리하고 실시간 업데이트를 처리하는 React 훅을 구현합니다.",
            "dependencies": [],
            "details": "useQuestions 훅은 질문 목록 조회, 실시간 구독 설정, 질문 추가 기능을 제공합니다. Supabase 실시간 구독을 통해 INSERT, UPDATE, DELETE 이벤트를 처리하고, 상태(questions, loading, error)를 관리합니다. 사용자 인증 정보를 활용하여 질문 작성자 정보를 저장하고, 세션 ID를 기반으로 해당 세션의 질문만 필터링합니다.",
            "status": "done",
            "testStrategy": "질문 목록 로드 기능, 실시간 업데이트 처리, 질문 추가 기능, 오류 처리 로직을 테스트합니다. 모의 Supabase 응답을 사용하여 다양한 시나리오를 검증합니다."
          },
          {
            "id": 2,
            "title": "질문 작성 폼 컴포넌트 구현",
            "description": "사용자가 새로운 질문을 작성할 수 있는 폼 컴포넌트를 개발합니다.",
            "dependencies": [
              1
            ],
            "details": "QuestionForm 컴포넌트는 텍스트 입력 필드와 제출 버튼을 포함합니다. 사용자 입력을 관리하는 상태(useState)를 구현하고, 폼 제출 시 useQuestions 훅의 addQuestion 함수를 호출합니다. 입력 유효성 검사를 수행하고, 제출 중 로딩 상태를 표시합니다. 오류 발생 시 사용자에게 적절한 피드백을 제공합니다. 로그인하지 않은 사용자에게는 안내 메시지를 표시합니다.",
            "status": "done",
            "testStrategy": "폼 제출 기능, 입력 유효성 검사, 오류 처리, 로딩 상태 표시, 비로그인 사용자 처리 로직을 테스트합니다."
          },
          {
            "id": 3,
            "title": "질문 목록 컴포넌트 구현",
            "description": "세션에 등록된 모든 질문을 목록 형태로 표시하는 컴포넌트를 개발합니다.",
            "dependencies": [
              1
            ],
            "details": "QuestionList 컴포넌트는 useQuestions 훅을 사용하여 질문 데이터를 가져오고, 각 질문을 QuestionItem 컴포넌트로 렌더링합니다. 로딩 상태와 오류 상태를 처리하고, 질문이 없을 때 적절한 메시지를 표시합니다. 질문 목록은 좋아요 수와 최신순으로 정렬할 수 있는 옵션을 제공합니다. 무한 스크롤 또는 페이지네이션을 구현하여 많은 질문을 효율적으로 표시합니다.",
            "status": "done",
            "testStrategy": "질문 목록 렌더링, 정렬 기능, 로딩 상태 표시, 오류 처리, 빈 목록 처리 로직을 테스트합니다."
          },
          {
            "id": 4,
            "title": "질문 아이템 컴포넌트 구현",
            "description": "개별 질문을 표시하는 컴포넌트로, 질문 내용, 작성자, 좋아요 수 등을 보여줍니다.",
            "dependencies": [
              1
            ],
            "details": "QuestionItem 컴포넌트는 질문 객체를 props로 받아 질문 내용, 작성 시간, 좋아요 수를 표시합니다. 좋아요 버튼을 클릭하면 Supabase API를 호출하여 좋아요를 추가/제거합니다. 질문 작성자인 경우 질문 수정/삭제 옵션을 제공합니다. 질문 상태(normal, answered, highlighted)에 따라 다른 스타일을 적용합니다. 시간 형식은 상대적 시간(예: '5분 전')으로 표시합니다.",
            "status": "done",
            "testStrategy": "질문 정보 표시, 좋아요 기능, 작성자 전용 기능(수정/삭제), 상태별 스타일링, 상대적 시간 표시 기능을 테스트합니다."
          },
          {
            "id": 5,
            "title": "질문 정렬 및 필터링 기능 구현",
            "description": "질문 목록을 다양한 기준(좋아요 수, 최신순)으로 정렬하고 상태별로 필터링하는 기능을 구현합니다.",
            "dependencies": [
              1,
              3
            ],
            "details": "정렬 옵션(좋아요 수, 최신순)을 선택할 수 있는 UI 컴포넌트를 구현합니다. 질문 상태(모든 질문, 답변된 질문, 하이라이트된 질문)별 필터링 기능을 제공합니다. 선택된 정렬/필터링 옵션에 따라 useQuestions 훅의 쿼리를 동적으로 변경합니다. 사용자 선택을 URL 쿼리 파라미터에 저장하여 페이지 새로고침 후에도 유지합니다. 정렬/필터링 상태를 로컬 스토리지에 저장하여 사용자 선호도를 기억합니다.",
            "status": "done",
            "testStrategy": "정렬 기능, 필터링 기능, URL 쿼리 파라미터 처리, 로컬 스토리지 저장 기능, UI 상태 업데이트를 테스트합니다."
          }
        ]
      },
      {
        "id": 6,
        "title": "좋아요 기능 구현 (실시간)",
        "description": "참가자가 질문에 좋아요를 표시하고 실시간으로 좋아요 수가 업데이트되는 기능을 구현합니다.",
        "details": "1. 좋아요 관리 훅 생성 (src/hooks/useLikes.ts):\n```tsx\nimport { useState, useEffect } from 'react';\nimport { supabase } from '../lib/supabase';\nimport { useAuth } from '../contexts/AuthContext';\n\nexport function useLikes() {\n  const { user } = useAuth();\n  const [likedQuestions, setLikedQuestions] = useState<Record<string, boolean>>({});\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // 사용자가 좋아요한 질문 목록 가져오기\n  useEffect(() => {\n    if (!user) {\n      setLikedQuestions({});\n      setLoading(false);\n      return;\n    }\n\n    const fetchLikedQuestions = async () => {\n      setLoading(true);\n      try {\n        const { data, error } = await supabase\n          .from('likes')\n          .select('question_id')\n          .eq('participant_id', user.id);\n        \n        if (error) throw error;\n        \n        const likedMap: Record<string, boolean> = {};\n        data?.forEach(like => {\n          likedMap[like.question_id] = true;\n        });\n        \n        setLikedQuestions(likedMap);\n      } catch (err: any) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchLikedQuestions();\n\n    // 실시간 구독 설정\n    const subscription = supabase\n      .channel(`likes:participant_id=eq.${user.id}`)\n      .on('postgres_changes', { \n        event: '*', \n        schema: 'public', \n        table: 'likes',\n        filter: `participant_id=eq.${user.id}`\n      }, (payload) => {\n        if (payload.eventType === 'INSERT') {\n          setLikedQuestions(prev => ({\n            ...prev,\n            [payload.new.question_id]: true\n          }));\n        } else if (payload.eventType === 'DELETE') {\n          setLikedQuestions(prev => {\n            const updated = { ...prev };\n            delete updated[payload.old.question_id];\n            return updated;\n          });\n        }\n      })\n      .subscribe();\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [user]);\n\n  // 좋아요 토글 함수\n  const toggleLike = async (questionId: string) => {\n    if (!user) return false;\n    \n    try {\n      if (likedQuestions[questionId]) {\n        // 좋아요 취소\n        const { error } = await supabase\n          .from('likes')\n          .delete()\n          .eq('question_id', questionId)\n          .eq('participant_id', user.id);\n        \n        if (error) throw error;\n      } else {\n        // 좋아요 추가\n        const { error } = await supabase\n          .from('likes')\n          .insert({\n            question_id: questionId,\n            participant_id: user.id\n          });\n        \n        if (error) throw error;\n      }\n      \n      return true;\n    } catch (err: any) {\n      setError(err.message);\n      return false;\n    }\n  };\n\n  return {\n    likedQuestions,\n    loading,\n    error,\n    toggleLike,\n    isLiked: (questionId: string) => !!likedQuestions[questionId]\n  };\n}\n```\n\n2. 좋아요 버튼 컴포넌트 구현 (src/components/questions/LikeButton.tsx)\n3. 질문 아이템에 좋아요 버튼 통합\n4. 좋아요 수에 따른 질문 정렬 기능 구현\n5. 좋아요 상태에 따른 UI 변경 (색상, 아이콘 등)",
        "testStrategy": "1. 좋아요 추가 기능 테스트\n2. 좋아요 취소 기능 테스트\n3. 실시간 좋아요 수 업데이트 테스트\n4. 좋아요 상태 유지 테스트 (페이지 새로고침 후)\n5. 좋아요 수에 따른 질문 정렬 테스트\n6. 비로그인 사용자의 좋아요 시도 처리 테스트",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "질문 상태 관리 기능 구현 (발표자)",
        "description": "발표자가 질문의 상태(숨김, 고정, 답변완료)를 관리할 수 있는 기능을 구현합니다.",
        "details": "1. 질문 상태 관리 훅 생성 (src/hooks/useQuestionStatus.ts):\n```tsx\nimport { useState } from 'react';\nimport { supabase } from '../lib/supabase';\nimport { useAuth } from '../contexts/AuthContext';\n\nexport function useQuestionStatus(sessionId: string) {\n  const { user } = useAuth();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // 세션 소유자 확인\n  const checkSessionOwnership = async () => {\n    if (!user || !sessionId) return false;\n    \n    try {\n      const { data, error } = await supabase\n        .from('sessions')\n        .select('presenter_id')\n        .eq('id', sessionId)\n        .single();\n      \n      if (error) throw error;\n      return data.presenter_id === user.id;\n    } catch (err) {\n      return false;\n    }\n  };\n\n  // 질문 상태 업데이트 함수\n  const updateQuestionStatus = async (questionId: string, status: 'normal' | 'hidden' | 'pinned' | 'answered') => {\n    if (!user || !sessionId) return false;\n    \n    // 세션 소유자 확인\n    const isOwner = await checkSessionOwnership();\n    if (!isOwner) {\n      setError('권한이 없습니다.');\n      return false;\n    }\n    \n    setLoading(true);\n    setError(null);\n    \n    try {\n      // 고정 상태로 변경 시 기존 고정된 질문 해제\n      if (status === 'pinned') {\n        await supabase\n          .from('questions')\n          .update({ status: 'normal' })\n          .eq('session_id', sessionId)\n          .eq('status', 'pinned');\n      }\n      \n      // 질문 상태 업데이트\n      const { error } = await supabase\n        .from('questions')\n        .update({ status, updated_at: new Date() })\n        .eq('id', questionId);\n      \n      if (error) throw error;\n      return true;\n    } catch (err: any) {\n      setError(err.message);\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // 질문 숨기기\n  const hideQuestion = (questionId: string) => updateQuestionStatus(questionId, 'hidden');\n  \n  // 질문 고정하기\n  const pinQuestion = (questionId: string) => updateQuestionStatus(questionId, 'pinned');\n  \n  // 질문 답변완료 표시\n  const markAsAnswered = (questionId: string) => updateQuestionStatus(questionId, 'answered');\n  \n  // 질문 상태 초기화\n  const resetQuestionStatus = (questionId: string) => updateQuestionStatus(questionId, 'normal');\n\n  return {\n    hideQuestion,\n    pinQuestion,\n    markAsAnswered,\n    resetQuestionStatus,\n    loading,\n    error\n  };\n}\n```\n\n2. 질문 상태 관리 컴포넌트 구현 (src/components/questions/QuestionStatusControls.tsx)\n3. 발표자 전용 질문 관리 UI 구현\n4. 질문 상태에 따른 스타일링 및 표시 방식 구현\n5. 고정된 질문을 상단에 표시하는 기능 구현",
        "testStrategy": "1. 질문 숨기기 기능 테스트\n2. 질문 고정하기 기능 테스트\n3. 질문 답변완료 표시 기능 테스트\n4. 질문 상태 초기화 기능 테스트\n5. 권한 검사 테스트 (발표자가 아닌 사용자의 상태 변경 시도)\n6. 실시간 상태 업데이트 테스트",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "발표자 대시보드 UI 구현",
        "description": "발표자가 세션을 관리하고 질문을 모니터링할 수 있는 대시보드 UI를 구현합니다.",
        "details": "1. 발표자 대시보드 페이지 구현 (src/pages/PresenterDashboard.tsx):\n```tsx\nimport { useEffect, useState } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { supabase } from '../lib/supabase';\nimport { useAuth } from '../contexts/AuthContext';\nimport { useQuestions } from '../hooks/useQuestions';\nimport { useQuestionStatus } from '../hooks/useQuestionStatus';\n\nimport QuestionList from '../components/questions/QuestionList';\nimport QuestionStatusControls from '../components/questions/QuestionStatusControls';\nimport SessionInfo from '../components/sessions/SessionInfo';\nimport QRCodeDisplay from '../components/sessions/QRCodeDisplay';\n\nexport default function PresenterDashboard() {\n  const { sessionId } = useParams<{ sessionId: string }>();\n  const navigate = useNavigate();\n  const { user } = useAuth();\n  const [session, setSession] = useState<any>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  const { questions } = useQuestions(sessionId || '');\n  const { \n    hideQuestion, \n    pinQuestion, \n    markAsAnswered, \n    resetQuestionStatus \n  } = useQuestionStatus(sessionId || '');\n\n  useEffect(() => {\n    if (!sessionId || !user) return;\n\n    const fetchSession = async () => {\n      setLoading(true);\n      try {\n        const { data, error } = await supabase\n          .from('sessions')\n          .select('*')\n          .eq('id', sessionId)\n          .eq('presenter_id', user.id)\n          .single();\n        \n        if (error) throw error;\n        setSession(data);\n      } catch (err: any) {\n        setError(err.message);\n        navigate('/my-sessions');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchSession();\n  }, [sessionId, user, navigate]);\n\n  const handleEndSession = async () => {\n    if (!session) return;\n    \n    try {\n      const { error } = await supabase\n        .from('sessions')\n        .update({ status: 'closed', updated_at: new Date() })\n        .eq('id', session.id);\n      \n      if (error) throw error;\n      setSession({ ...session, status: 'closed' });\n    } catch (err: any) {\n      setError(err.message);\n    }\n  };\n\n  if (loading) return <div>로딩 중...</div>;\n  if (error) return <div>오류: {error}</div>;\n  if (!session) return <div>세션을 찾을 수 없습니다.</div>;\n\n  return (\n    <div className=\"container mx-auto p-4\">\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n        <div className=\"md:col-span-1\">\n          <SessionInfo session={session} />\n          <QRCodeDisplay sessionCode={session.session_code} />\n          <div className=\"mt-4\">\n            <button \n              onClick={handleEndSession}\n              disabled={session.status === 'closed'}\n              className=\"btn btn-danger w-full\"\n            >\n              {session.status === 'active' ? '세션 종료' : '종료됨'}\n            </button>\n          </div>\n        </div>\n        \n        <div className=\"md:col-span-2\">\n          <h2 className=\"text-2xl font-bold mb-4\">질문 관리</h2>\n          <QuestionList \n            questions={questions} \n            showControls \n            onHide={hideQuestion}\n            onPin={pinQuestion}\n            onMarkAnswered={markAsAnswered}\n            onResetStatus={resetQuestionStatus}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n2. 세션 정보 컴포넌트 구현 (src/components/sessions/SessionInfo.tsx)\n3. QR 코드 표시 컴포넌트 구현 (src/components/sessions/QRCodeDisplay.tsx)\n4. 발표자 세션 목록 페이지 구현 (src/pages/MySessionsPage.tsx)\n5. 대시보드 레이아웃 및 스타일링 구현\n6. 실시간 질문 모니터링 및 관리 UI 구현",
        "testStrategy": "1. 발표자 대시보드 로드 테스트\n2. 세션 정보 표시 테스트\n3. QR 코드 생성 및 표시 테스트\n4. 질문 목록 표시 및 관리 기능 테스트\n5. 세션 종료 기능 테스트\n6. 권한 검사 테스트 (다른 발표자의 세션 접근 시도)",
        "priority": "medium",
        "dependencies": [
          4,
          5,
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "대시보드 레이아웃 및 기본 구조 구현",
            "description": "발표자 대시보드의 전체 레이아웃과 기본 구조를 구현합니다. 반응형 그리드 시스템을 활용하여 모바일과 데스크톱 환경에 모두 적합한 UI를 설계합니다.",
            "dependencies": [],
            "details": "1. PresenterDashboard.tsx 파일에 기본 레이아웃 구조 구현\n2. 그리드 시스템을 사용하여 좌측에 세션 정보 패널, 우측에 질문 관리 패널 배치\n3. 모바일 환경에서는 단일 컬럼으로 변환되도록 반응형 설계 적용\n4. 로딩 상태, 에러 상태, 빈 상태에 대한 UI 처리\n5. 세션 데이터 로드 및 권한 검증 로직 구현",
            "status": "done",
            "testStrategy": "1. 다양한 화면 크기에서 레이아웃 테스트\n2. 로딩, 에러, 빈 상태 UI 테스트\n3. 권한 없는 사용자의 접근 시 리다이렉트 테스트"
          },
          {
            "id": 2,
            "title": "세션 정보 컴포넌트 구현",
            "description": "발표자 세션의 상세 정보를 표시하는 컴포넌트를 구현합니다. 세션 제목, 코드, 상태, 생성 시간 등의 정보를 보기 좋게 표시합니다.",
            "dependencies": [
              1
            ],
            "details": "1. SessionInfo.tsx 컴포넌트 구현\n2. 세션 객체를 props로 받아 정보 표시\n3. 세션 상태(활성/종료)에 따른 시각적 표시 구현\n4. 세션 생성 시간을 사용자 친화적인 형식으로 변환하여 표시\n5. 세션 코드를 강조하여 표시\n6. 스타일링을 위한 shadcn/ui 컴포넌트 활용",
            "status": "done",
            "testStrategy": "1. 다양한 세션 데이터로 렌더링 테스트\n2. 세션 상태에 따른 UI 변화 테스트\n3. 날짜 형식 변환 정확성 테스트"
          },
          {
            "id": 3,
            "title": "QR 코드 표시 컴포넌트 구현",
            "description": "세션 참여 링크를 포함한 QR 코드를 생성하고 표시하는 컴포넌트를 구현합니다. 참가자들이 쉽게 세션에 참여할 수 있도록 합니다.",
            "dependencies": [
              1
            ],
            "details": "1. QRCodeDisplay.tsx 컴포넌트 구현\n2. qrcode.react 라이브러리를 사용하여 세션 코드 기반 QR 코드 생성\n3. QR 코드 크기 조정 옵션 제공\n4. QR 코드 아래에 세션 코드 텍스트로 표시\n5. QR 코드 이미지 다운로드 기능 추가\n6. 세션 참여 URL을 클립보드에 복사하는 기능 구현",
            "status": "done",
            "testStrategy": "1. QR 코드 생성 정확성 테스트\n2. 다양한 세션 코드로 QR 생성 테스트\n3. 복사 기능 동작 테스트\n4. 다운로드 기능 테스트"
          },
          {
            "id": 4,
            "title": "질문 관리 섹션 구현",
            "description": "발표자가 참가자들의 질문을 관리할 수 있는 UI 섹션을 구현합니다. 질문 목록 표시, 핀 고정, 숨김, 답변 완료 표시 등의 기능을 제공합니다.",
            "dependencies": [
              1
            ],
            "details": "1. QuestionList 컴포넌트와 연동하여 질문 목록 표시\n2. 질문 필터링 옵션 구현 (모든 질문, 답변된 질문, 핀 고정된 질문 등)\n3. 질문 정렬 옵션 구현 (최신순, 좋아요순)\n4. 각 질문에 대한 관리 컨트롤 표시 (핀 고정, 숨김, 답변 완료 표시)\n5. useQuestionStatus 훅과 연동하여 질문 상태 변경 기능 구현\n6. 실시간 업데이트를 위한 Supabase 구독 설정",
            "status": "done",
            "testStrategy": "1. 질문 목록 렌더링 테스트\n2. 필터링 및 정렬 기능 테스트\n3. 질문 상태 변경 기능 테스트\n4. 실시간 업데이트 테스트"
          },
          {
            "id": 5,
            "title": "세션 상태 관리 기능 구현",
            "description": "발표자가 세션의 상태를 관리할 수 있는 기능을 구현합니다. 세션 종료, 재개 등의 기능을 제공하고 상태 변경에 따른 UI 업데이트를 처리합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. 세션 종료 버튼 및 기능 구현\n2. 세션 상태에 따른 UI 변화 처리\n3. 세션 상태 변경 시 Supabase 데이터베이스 업데이트\n4. 세션 종료 전 확인 대화상자 구현\n5. 세션 종료 후 참가자들에게 알림 기능 구현\n6. 세션 상태 변경 후 실시간으로 UI 업데이트",
            "status": "done",
            "testStrategy": "1. 세션 상태 변경 기능 테스트\n2. 상태 변경 후 UI 업데이트 테스트\n3. 확인 대화상자 동작 테스트\n4. 데이터베이스 업데이트 정확성 테스트"
          }
        ]
      },
      {
        "id": 9,
        "title": "참가자 뷰 UI 구현",
        "description": "참가자가 세션에 참가하여 질문을 작성하고 투표할 수 있는 UI를 구현합니다.",
        "details": "1. 참가자 세션 뷰 페이지 구현 (src/pages/ParticipantView.tsx):\n```tsx\nimport { useEffect, useState } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { supabase } from '../lib/supabase';\nimport { useQuestions } from '../hooks/useQuestions';\nimport { useLikes } from '../hooks/useLikes';\n\nimport QuestionForm from '../components/questions/QuestionForm';\nimport QuestionList from '../components/questions/QuestionList';\nimport SessionHeader from '../components/sessions/SessionHeader';\n\nexport default function ParticipantView() {\n  const { sessionCode } = useParams<{ sessionCode: string }>();\n  const navigate = useNavigate();\n  const [session, setSession] = useState<any>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  // 세션 ID 상태 추가\n  const [sessionId, setSessionId] = useState<string>('');\n  \n  // 세션 ID가 설정된 후에만 hooks 사용\n  const { questions, addQuestion } = useQuestions(sessionId);\n  const { toggleLike, isLiked } = useLikes();\n\n  useEffect(() => {\n    if (!sessionCode) return;\n\n    const fetchSession = async () => {\n      setLoading(true);\n      try {\n        const { data, error } = await supabase\n          .from('sessions')\n          .select('*')\n          .eq('session_code', sessionCode)\n          .eq('status', 'active')\n          .single();\n        \n        if (error) throw error;\n        setSession(data);\n        setSessionId(data.id);\n      } catch (err: any) {\n        setError('세션을 찾을 수 없거나 종료되었습니다.');\n        setTimeout(() => navigate('/'), 3000);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchSession();\n    \n    // 세션 상태 변경 구독\n    const subscription = supabase\n      .channel(`session:${sessionCode}`)\n      .on('postgres_changes', { \n        event: 'UPDATE', \n        schema: 'public', \n        table: 'sessions',\n        filter: `session_code=eq.${sessionCode}`\n      }, (payload) => {\n        if (payload.new.status === 'closed') {\n          setError('세션이 종료되었습니다.');\n          setTimeout(() => navigate('/'), 3000);\n        }\n      })\n      .subscribe();\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [sessionCode, navigate]);\n\n  const handleSubmitQuestion = async (content: string) => {\n    if (!content.trim()) return;\n    await addQuestion(content);\n  };\n\n  if (loading) return <div>로딩 중...</div>;\n  if (error) return <div>오류: {error}</div>;\n  if (!session) return <div>세션을 찾을 수 없습니다.</div>;\n\n  return (\n    <div className=\"container mx-auto p-4\">\n      <SessionHeader title={session.title} code={session.session_code} />\n      \n      <div className=\"my-6\">\n        <QuestionForm onSubmit={handleSubmitQuestion} />\n      </div>\n      \n      <div>\n        <h2 className=\"text-xl font-semibold mb-4\">질문 목록</h2>\n        <QuestionList \n          questions={questions} \n          showControls={false}\n          onLike={toggleLike}\n          isLiked={isLiked}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n2. 세션 헤더 컴포넌트 구현 (src/components/sessions/SessionHeader.tsx)\n3. 질문 작성 폼 컴포넌트 구현 (src/components/questions/QuestionForm.tsx)\n4. 참가자용 질문 목록 컴포넌트 구현\n5. 좋아요 버튼 및 카운터 구현\n6. 세션 종료 시 알림 및 리디렉션 구현",
        "testStrategy": "1. 세션 참가 및 정보 로드 테스트\n2. 질문 작성 기능 테스트\n3. 질문 목록 표시 테스트\n4. 좋아요 기능 테스트\n5. 실시간 업데이트 테스트\n6. 세션 종료 시 알림 및 리디렉션 테스트",
        "priority": "medium",
        "dependencies": [
          4,
          5,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "QR 코드 생성 및 스캔 기능 구현",
        "description": "세션 참가를 위한 QR 코드 생성 및 스캔 기능을 구현합니다.",
        "details": "1. QR 코드 생성 컴포넌트 구현 (src/components/sessions/QRCodeGenerator.tsx):\n```tsx\nimport { QRCodeSVG } from 'qrcode.react';\n\ninterface QRCodeGeneratorProps {\n  sessionCode: string;\n  size?: number;\n}\n\nexport default function QRCodeGenerator({ sessionCode, size = 200 }: QRCodeGeneratorProps) {\n  // 현재 도메인 기반으로 참가 URL 생성\n  const joinUrl = `${window.location.origin}/join/${sessionCode}`;\n  \n  return (\n    <div className=\"flex flex-col items-center\">\n      <div className=\"border-4 border-white p-2 bg-white rounded-lg shadow-md\">\n        <QRCodeSVG \n          value={joinUrl} \n          size={size} \n          level=\"H\" \n          includeMargin={true}\n          bgColor=\"#FFFFFF\"\n          fgColor=\"#000000\"\n        />\n      </div>\n      <div className=\"mt-4 text-center\">\n        <p className=\"text-lg font-bold\">세션 코드: {sessionCode}</p>\n        <p className=\"text-sm text-gray-500\">QR 코드를 스캔하거나 세션 코드를 입력하세요</p>\n      </div>\n    </div>\n  );\n}\n```\n\n2. QR 코드 스캔 컴포넌트 구현 (선택적 - 웹 카메라 접근 필요):\n```tsx\nimport { useState, useEffect } from 'react';\nimport { Html5Qrcode } from 'html5-qrcode';\n\ninterface QRCodeScannerProps {\n  onScan: (sessionCode: string) => void;\n}\n\nexport default function QRCodeScanner({ onScan }: QRCodeScannerProps) {\n  const [scanning, setScanning] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  useEffect(() => {\n    let html5QrCode: Html5Qrcode | null = null;\n    \n    const startScanner = async () => {\n      try {\n        html5QrCode = new Html5Qrcode('qr-reader');\n        setScanning(true);\n        \n        await html5QrCode.start(\n          { facingMode: 'environment' },\n          {\n            fps: 10,\n            qrbox: { width: 250, height: 250 }\n          },\n          (decodedText) => {\n            // URL에서 세션 코드 추출\n            const url = new URL(decodedText);\n            const pathParts = url.pathname.split('/');\n            const sessionCode = pathParts[pathParts.length - 1];\n            \n            if (sessionCode) {\n              onScan(sessionCode);\n              if (html5QrCode) {\n                html5QrCode.stop();\n                setScanning(false);\n              }\n            }\n          },\n          (errorMessage) => {\n            // 스캔 중 오류는 무시 (지속적인 스캔 시도)\n          }\n        );\n      } catch (err: any) {\n        setError(err.message || '카메라 접근에 실패했습니다.');\n        setScanning(false);\n      }\n    };\n    \n    startScanner();\n    \n    return () => {\n      if (html5QrCode && scanning) {\n        html5QrCode.stop().catch(err => console.error(err));\n      }\n    };\n  }, [onScan]);\n  \n  return (\n    <div className=\"qr-scanner-container\">\n      {error ? (\n        <div className=\"error-message\">{error}</div>\n      ) : (\n        <>\n          <div id=\"qr-reader\" style={{ width: '100%', maxWidth: '500px' }}></div>\n          {scanning && <p>QR 코드를 스캔하세요...</p>}\n        </>\n      )}\n    </div>\n  );\n}\n```\n\n3. 세션 참가 페이지에 QR 코드 스캔 기능 통합\n4. 발표자 대시보드에 QR 코드 생성 기능 통합\n5. 세션 코드 수동 입력 폼 구현\n6. 모바일 환경 최적화",
        "testStrategy": "1. QR 코드 생성 테스트\n2. 생성된 QR 코드 스캔 테스트\n3. QR 코드 스캔 후 세션 참가 테스트\n4. 세션 코드 수동 입력 테스트\n5. 다양한 모바일 기기에서의 호환성 테스트\n6. 오류 처리 테스트 (잘못된 QR 코드, 카메라 접근 거부 등)",
        "priority": "low",
        "dependencies": [
          4,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "스타일링 및 반응형 디자인 개선",
        "description": "shadcn/ui 컴포넌트를 활용하여 전체 애플리케이션의 스타일링을 개선하고 반응형 디자인을 구현합니다.",
        "details": "1. shadcn/ui 컴포넌트 추가 설치:\n```bash\nnpx shadcn-ui@latest add button\nnpx shadcn-ui@latest add card\nnpx shadcn-ui@latest add input\nnpx shadcn-ui@latest add form\nnpx shadcn-ui@latest add dialog\nnpx shadcn-ui@latest add tabs\nnpx shadcn-ui@latest add avatar\nnpx shadcn-ui@latest add badge\nnpx shadcn-ui@latest add toast\n```\n\n2. 전역 스타일 설정 (src/styles/globals.css):\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  :root {\n    --background: 0 0% 100%;\n    --foreground: 222.2 84% 4.9%;\n    --card: 0 0% 100%;\n    --card-foreground: 222.2 84% 4.9%;\n    --popover: 0 0% 100%;\n    --popover-foreground: 222.2 84% 4.9%;\n    --primary: 221.2 83.2% 53.3%;\n    --primary-foreground: 210 40% 98%;\n    --secondary: 210 40% 96.1%;\n    --secondary-foreground: 222.2 47.4% 11.2%;\n    --muted: 210 40% 96.1%;\n    --muted-foreground: 215.4 16.3% 46.9%;\n    --accent: 210 40% 96.1%;\n    --accent-foreground: 222.2 47.4% 11.2%;\n    --destructive: 0 84.2% 60.2%;\n    --destructive-foreground: 210 40% 98%;\n    --border: 214.3 31.8% 91.4%;\n    --input: 214.3 31.8% 91.4%;\n    --ring: 221.2 83.2% 53.3%;\n    --radius: 0.5rem;\n  }\n\n  .dark {\n    --background: 222.2 84% 4.9%;\n    --foreground: 210 40% 98%;\n    --card: 222.2 84% 4.9%;\n    --card-foreground: 210 40% 98%;\n    --popover: 222.2 84% 4.9%;\n    --popover-foreground: 210 40% 98%;\n    --primary: 217.2 91.2% 59.8%;\n    --primary-foreground: 222.2 47.4% 11.2%;\n    --secondary: 217.2 32.6% 17.5%;\n    --secondary-foreground: 210 40% 98%;\n    --muted: 217.2 32.6% 17.5%;\n    --muted-foreground: 215 20.2% 65.1%;\n    --accent: 217.2 32.6% 17.5%;\n    --accent-foreground: 210 40% 98%;\n    --destructive: 0 62.8% 30.6%;\n    --destructive-foreground: 210 40% 98%;\n    --border: 217.2 32.6% 17.5%;\n    --input: 217.2 32.6% 17.5%;\n    --ring: 224.3 76.3% 48%;\n  }\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n  body {\n    @apply bg-background text-foreground;\n  }\n}\n```\n\n3. 반응형 레이아웃 컴포넌트 구현 (src/components/layout/Layout.tsx):\n```tsx\nimport { ReactNode } from 'react';\nimport Header from './Header';\nimport Footer from './Footer';\n\ninterface LayoutProps {\n  children: ReactNode;\n}\n\nexport default function Layout({ children }: LayoutProps) {\n  return (\n    <div className=\"min-h-screen flex flex-col\">\n      <Header />\n      <main className=\"flex-grow container mx-auto px-4 py-8 md:px-6\">\n        {children}\n      </main>\n      <Footer />\n    </div>\n  );\n}\n```\n\n4. 모바일 최적화 스타일링:\n   - 모든 컴포넌트에 반응형 클래스 적용\n   - 터치 친화적인 UI 요소 (큰 버튼, 충분한 여백)\n   - 모바일 화면에 최적화된 레이아웃\n\n5. 다크 모드 지원 구현:\n```tsx\nimport { createContext, useContext, useEffect, useState } from 'react';\n\ntype Theme = 'dark' | 'light' | 'system';\n\ntype ThemeProviderProps = {\n  children: React.ReactNode;\n  defaultTheme?: Theme;\n};\n\ntype ThemeProviderState = {\n  theme: Theme;\n  setTheme: (theme: Theme) => void;\n};\n\nconst initialState: ThemeProviderState = {\n  theme: 'system',\n  setTheme: () => null,\n};\n\nconst ThemeProviderContext = createContext<ThemeProviderState>(initialState);\n\nexport function ThemeProvider({\n  children,\n  defaultTheme = 'system',\n}: ThemeProviderProps) {\n  const [theme, setTheme] = useState<Theme>(\n    () => (localStorage.getItem('theme') as Theme) || defaultTheme\n  );\n\n  useEffect(() => {\n    const root = window.document.documentElement;\n\n    root.classList.remove('light', 'dark');\n\n    if (theme === 'system') {\n      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)')\n        .matches\n        ? 'dark'\n        : 'light';\n\n      root.classList.add(systemTheme);\n      return;\n    }\n\n    root.classList.add(theme);\n  }, [theme]);\n\n  const value = {\n    theme,\n    setTheme: (theme: Theme) => {\n      localStorage.setItem('theme', theme);\n      setTheme(theme);\n    },\n  };\n\n  return (\n    <ThemeProviderContext.Provider value={value}>\n      {children}\n    </ThemeProviderContext.Provider>\n  );\n}\n\nexport const useTheme = () => {\n  const context = useContext(ThemeProviderContext);\n\n  if (context === undefined)\n    throw new Error('useTheme must be used within a ThemeProvider');\n\n  return context;\n};\n```\n\n6. 접근성 개선:\n   - 적절한 ARIA 속성 추가\n   - 키보드 네비게이션 지원\n   - 충분한 색상 대비 확보",
        "testStrategy": "1. 다양한 화면 크기에서의 반응형 디자인 테스트\n2. 모바일 기기에서의 사용성 테스트\n3. 다크 모드 전환 테스트\n4. 접근성 검사 도구를 사용한 접근성 테스트\n5. 다양한 브라우저에서의 호환성 테스트\n6. 터치 인터랙션 테스트",
        "priority": "medium",
        "dependencies": [
          1,
          8,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "shadcn/ui 컴포넌트 설치 및 기본 설정",
            "description": "필요한 shadcn/ui 컴포넌트를 설치하고 기본 설정을 완료합니다.",
            "dependencies": [],
            "details": "1. 필요한 shadcn/ui 컴포넌트 설치 (button, card, input, form, dialog, tabs, avatar, badge, toast)\n2. tailwind.config.js 파일 설정 확인 및 업데이트\n3. 컴포넌트 테마 설정 확인\n4. 컴포넌트 사용 예제 문서 검토\n5. 프로젝트에 맞게 컴포넌트 커스터마이징 방법 확인",
            "status": "done",
            "testStrategy": "1. 각 컴포넌트가 정상적으로 설치되었는지 확인\n2. 컴포넌트 렌더링 테스트\n3. 기본 스타일이 올바르게 적용되는지 확인"
          },
          {
            "id": 2,
            "title": "전역 스타일 및 테마 설정",
            "description": "애플리케이션 전체에 적용될 전역 스타일과 테마 시스템을 설정합니다.",
            "dependencies": [
              1
            ],
            "details": "1. globals.css 파일에 기본 스타일 및 변수 설정\n2. 색상 변수 및 테마 설정 (라이트/다크 모드)\n3. 타이포그래피 스타일 정의\n4. 공통 애니메이션 및 트랜지션 정의\n5. 레이아웃 기본 설정 (간격, 여백 등)\n6. ThemeProvider 컴포넌트 구현 및 적용",
            "status": "done",
            "testStrategy": "1. 테마 변수가 올바르게 적용되는지 확인\n2. 다크/라이트 모드 전환 테스트\n3. 전역 스타일이 모든 페이지에 일관되게 적용되는지 확인"
          },
          {
            "id": 3,
            "title": "레이아웃 컴포넌트 구현",
            "description": "애플리케이션의 기본 레이아웃 구조를 구현하고 반응형으로 설정합니다.",
            "dependencies": [
              2
            ],
            "details": "1. Layout 컴포넌트 구현 (Header, Footer, Main 영역 포함)\n2. Header 컴포넌트 구현 (네비게이션, 로고, 사용자 메뉴 등)\n3. Footer 컴포넌트 구현\n4. 사이드바/내비게이션 컴포넌트 구현\n5. 컨테이너 및 그리드 시스템 설정\n6. 반응형 브레이크포인트 설정 및 적용",
            "status": "done",
            "testStrategy": "1. 다양한 화면 크기에서 레이아웃 테스트\n2. 컴포넌트 간 정렬 및 간격 확인\n3. 네비게이션 요소의 반응형 동작 테스트"
          },
          {
            "id": 4,
            "title": "모바일 최적화 및 반응형 디자인 적용",
            "description": "모든 페이지와 컴포넌트에 반응형 디자인을 적용하고 모바일 환경에 최적화합니다.",
            "dependencies": [
              3
            ],
            "details": "1. 모든 페이지 컴포넌트에 반응형 클래스 적용\n2. 모바일 뷰에 최적화된 UI 요소 구현 (큰 버튼, 충분한 여백)\n3. 터치 친화적인 인터페이스 구현\n4. 미디어 쿼리를 활용한 화면 크기별 레이아웃 조정\n5. 이미지 및 미디어 요소의 반응형 처리\n6. 모바일 네비게이션 메뉴 구현 (햄버거 메뉴 등)",
            "status": "done",
            "testStrategy": "1. 다양한 모바일 기기에서의 레이아웃 테스트\n2. 터치 인터랙션 테스트\n3. 화면 회전 시 레이아웃 변화 테스트\n4. 다양한 화면 크기에서의 컨텐츠 가독성 확인"
          },
          {
            "id": 5,
            "title": "다크 모드 및 접근성 개선",
            "description": "다크 모드 지원을 완성하고 애플리케이션 전반의 접근성을 개선합니다.",
            "dependencies": [
              2,
              4
            ],
            "details": "1. ThemeProvider를 사용한 다크 모드 전환 기능 구현\n2. 시스템 설정에 따른 자동 테마 적용\n3. 모든 컴포넌트에 적절한 ARIA 속성 추가\n4. 키보드 네비게이션 지원 구현\n5. 충분한 색상 대비 확보\n6. 스크린 리더 호환성 개선\n7. 접근성 체크리스트 검토 및 적용",
            "status": "done",
            "testStrategy": "1. 다크 모드 전환 기능 테스트\n2. 접근성 검사 도구를 사용한 검증 (예: Lighthouse, axe)\n3. 키보드 네비게이션 테스트\n4. 스크린 리더 호환성 테스트\n5. 색상 대비 검사"
          }
        ]
      },
      {
        "id": 12,
        "title": "테스트 및 배포",
        "description": "애플리케이션의 테스트를 수행하고 Vercel에 배포합니다.",
        "details": "1. 테스트 설정:\n```bash\nnpm install -D vitest @testing-library/react @testing-library/jest-dom jsdom\n```\n\n2. Vitest 설정 (vite.config.ts):\n```typescript\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n    environment: 'jsdom',\n    setupFiles: './src/test/setup.ts',\n  },\n});\n```\n\n3. 테스트 설정 파일 (src/test/setup.ts):\n```typescript\nimport '@testing-library/jest-dom';\n```\n\n4. 컴포넌트 테스트 예시 (src/components/questions/QuestionForm.test.tsx):\n```tsx\nimport { describe, it, expect, vi } from 'vitest';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport QuestionForm from './QuestionForm';\n\ndescribe('QuestionForm', () => {\n  it('renders the form correctly', () => {\n    render(<QuestionForm onSubmit={() => {}} />);\n    expect(screen.getByPlaceholderText(/질문을 입력하세요/i)).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /질문 등록/i })).toBeInTheDocument();\n  });\n\n  it('calls onSubmit with the question when form is submitted', async () => {\n    const handleSubmit = vi.fn();\n    render(<QuestionForm onSubmit={handleSubmit} />);\n    \n    const input = screen.getByPlaceholderText(/질문을 입력하세요/i);\n    const submitButton = screen.getByRole('button', { name: /질문 등록/i });\n    \n    fireEvent.change(input, { target: { value: '테스트 질문입니다.' } });\n    fireEvent.click(submitButton);\n    \n    expect(handleSubmit).toHaveBeenCalledWith('테스트 질문입니다.');\n    expect(input).toHaveValue('');\n  });\n\n  it('does not submit empty questions', () => {\n    const handleSubmit = vi.fn();\n    render(<QuestionForm onSubmit={handleSubmit} />);\n    \n    const submitButton = screen.getByRole('button', { name: /질문 등록/i });\n    fireEvent.click(submitButton);\n    \n    expect(handleSubmit).not.toHaveBeenCalled();\n  });\n});\n```\n\n5. 배포 준비:\n   - 환경 변수 설정 (.env.production)\n   - 빌드 스크립트 확인\n   - 메타데이터 및 SEO 최적화\n\n6. Vercel 배포:\n```bash\n# Vercel CLI 설치\nnpm install -g vercel\n\n# 로그인\nvercel login\n\n# 배포\nvercel\n```\n\n7. 배포 후 확인 사항:\n   - 모든 기능이 프로덕션 환경에서 정상 작동하는지 확인\n   - 성능 모니터링\n   - 오류 로깅 설정",
        "testStrategy": "1. 단위 테스트 실행 및 검증\n2. 통합 테스트 실행 및 검증\n3. 엔드투엔드 테스트 (수동)\n4. 크로스 브라우저 테스트\n5. 모바일 기기 테스트\n6. 성능 테스트 (Lighthouse 점수 확인)\n7. 배포 후 프로덕션 환경 검증",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "테스트 환경 설정 (Vitest, Testing Library)",
            "description": "테스트 프레임워크와 도구를 설치하고 프로젝트에 테스트 환경을 구성합니다.",
            "dependencies": [],
            "details": "필요한 테스트 라이브러리(vitest, @testing-library/react, @testing-library/jest-dom, jsdom)를 설치하고, vite.config.ts에 테스트 설정을 추가합니다. 테스트 설정 파일(src/test/setup.ts)을 생성하고 package.json에 테스트 스크립트를 추가합니다. 테스트 디렉토리 구조를 설정하고 테스트 실행 환경을 구성합니다.",
            "status": "done",
            "testStrategy": "설치된 패키지가 정상적으로 동작하는지 확인하기 위해 간단한 샘플 테스트를 작성하고 실행합니다. 테스트 설정이 올바르게 구성되었는지 확인하기 위해 'npm test' 명령어로 테스트 실행을 검증합니다."
          },
          {
            "id": 2,
            "title": "단위 테스트 구현",
            "description": "개별 컴포넌트와 함수에 대한 단위 테스트를 작성하고 실행합니다.",
            "dependencies": [
              1
            ],
            "details": "주요 컴포넌트(QuestionForm, QuestionList, SessionForm 등)에 대한 단위 테스트를 작성합니다. 각 컴포넌트의 렌더링, 이벤트 핸들링, 상태 변경 등을 테스트합니다. 유틸리티 함수와 커스텀 훅에 대한 테스트도 구현합니다. 테스트 커버리지를 확인하고 필요한 경우 추가 테스트를 작성합니다.",
            "status": "done",
            "testStrategy": "각 컴포넌트의 렌더링, 사용자 인터랙션, 상태 변경을 검증합니다. 모킹을 사용하여 외부 의존성을 격리합니다. 테스트 커버리지 80% 이상을 목표로 합니다. 경계 조건과 오류 상황에 대한 테스트 케이스를 포함합니다."
          },
          {
            "id": 3,
            "title": "통합 테스트 구현",
            "description": "여러 컴포넌트가 함께 작동하는 통합 테스트를 작성하고 실행합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "주요 페이지(세션 생성, 질문 목록, 실시간 업데이트 등)에 대한 통합 테스트를 작성합니다. Supabase 클라이언트를 모킹하여 데이터베이스 상호작용을 테스트합니다. 실시간 구독 기능에 대한 테스트를 구현합니다. 사용자 인증 흐름과 보호된 라우트에 대한 테스트를 작성합니다. 전체 애플리케이션 흐름을 검증하는 테스트를 구현합니다.",
            "status": "done",
            "testStrategy": "주요 사용자 흐름(발표자 세션 생성, 참가자 질문 등록, 좋아요 기능 등)을 시뮬레이션하는 테스트를 작성합니다. MSW(Mock Service Worker)나 Supabase 모킹을 통해 API 요청을 가로채고 응답을 시뮬레이션합니다. 비동기 작업과 상태 업데이트를 올바르게 테스트합니다."
          },
          {
            "id": 4,
            "title": "배포 환경 설정",
            "description": "프로덕션 배포를 위한 환경 변수 설정 및 빌드 최적화를 구성합니다.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "프로덕션용 환경 변수(.env.production)를 설정합니다. 메타데이터 및 SEO 최적화를 위한 설정을 추가합니다. 빌드 스크립트를 확인하고 필요한 경우 최적화합니다. 정적 애셋 최적화 및 코드 분할 설정을 구성합니다. 성능 최적화를 위한 설정(이미지 최적화, 지연 로딩 등)을 추가합니다. 보안 관련 설정(CSP, CORS 등)을 구성합니다.",
            "status": "done",
            "testStrategy": "프로덕션 빌드를 로컬에서 실행하여 모든 기능이 정상 작동하는지 확인합니다. Lighthouse를 사용하여 성능, 접근성, SEO 점수를 측정합니다. 빌드 결과물의 크기와 로딩 시간을 분석합니다."
          },
          {
            "id": 5,
            "title": "Vercel 배포 구성",
            "description": "Vercel 플랫폼에 애플리케이션을 배포하기 위한 설정과 배포 프로세스를 구현합니다.",
            "dependencies": [
              4
            ],
            "details": "Vercel CLI를 설치하고 계정에 로그인합니다. vercel.json 설정 파일을 생성하여 배포 설정을 구성합니다. 환경 변수를 Vercel 프로젝트에 설정합니다. 배포 명령어를 실행하여 애플리케이션을 배포합니다. 필요한 경우 커스텀 도메인을 설정합니다. GitHub 저장소와 Vercel을 연결하여 자동 배포를 설정합니다. 배포 브랜치 및 프리뷰 배포 설정을 구성합니다.",
            "status": "done",
            "testStrategy": "배포된 애플리케이션에 접속하여 모든 기능이 정상 작동하는지 확인합니다. 환경 변수가 올바르게 적용되었는지 확인합니다. 자동 배포 파이프라인이 정상 작동하는지 테스트합니다. 배포 후 발생할 수 있는 CORS 이슈나 API 연결 문제를 확인합니다."
          },
          {
            "id": 6,
            "title": "배포 후 검증 및 모니터링 설정",
            "description": "배포된 애플리케이션의 성능과 안정성을 모니터링하고 오류를 추적하는 시스템을 구축합니다.",
            "dependencies": [
              5
            ],
            "details": "Sentry나 LogRocket과 같은 오류 추적 도구를 설정합니다. 성능 모니터링을 위한 도구(Vercel Analytics, Google Analytics 등)를 구성합니다. 사용자 행동 분석을 위한 이벤트 추적을 설정합니다. 서버 상태 모니터링을 구성합니다. 알림 시스템을 설정하여 중요한 오류나 성능 이슈 발생 시 알림을 받도록 합니다. 정기적인 백업 및 복구 전략을 수립합니다. 보안 취약점 스캔 및 모니터링을 설정합니다.",
            "status": "done",
            "testStrategy": "오류 추적 시스템이 정상적으로 작동하는지 테스트 오류를 발생시켜 확인합니다. 성능 모니터링 도구가 데이터를 올바르게 수집하는지 확인합니다. 알림 시스템이 중요한 이슈 발생 시 알림을 보내는지 테스트합니다. 다양한 기기와 브라우저에서 애플리케이션을 테스트하여 호환성을 확인합니다."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-13T06:50:04.035Z",
      "updated": "2025-11-13T08:21:29.977Z",
      "description": "Tasks for master context"
    }
  }
}